
stk 0 i
# current stack now has this instruction pointer
# next line is debug
# ldm a s

# output an "a" which tells the other side that we need a "q"
imm a 1
imm b 0x61
stk 0 b
imm b 0
add b s
imm c 1

sys write d
# reset stack
stk a 0

# push two spaces onto the stack so that we don't overwrite saved ip
imm a 0
stk 0 a
stk 0 a
add a s

# push quit on the buffer, going to race to change the flag
imm b 0x7571
stm a b

imm c 2
add a c

imm b 0x7469
stm a b

# Address of fname goes into b
imm b 0
add b s

# &flags in the same buffer, and goes in d
imm d 0x0
add d b

imm c 1
imm a 0

sys 0x3 d

# pop off the stack
stk a 0
stk a 0

# Try to write out "s" to the fd

# buf in b
imm b 0x73
stk 0 b 
imm b 0
add b s

# len in c
imm c 0x1

# fd in a
imm a 11

sys write d

# clear the stack
stk a 0

# c has where we want to jump to
stk c 0
stk 0 c
imm a 1
cmp d a
jmp != c

# output a "b" which tells the other side that we are ready for the next stage
imm a 1
imm b 0x62
stk 0 b
imm b 0
add b s
imm c 1

sys write d

stk a 0

# FD of `quit` is 11, which is where we want to write

# Let's just read 1024 at a time until EOF!
# # read in 2 bytes that's how much they want to write
# # then the parallel code, which will be written to quit fd

imm b 0
stk 0 b
add b s

# len in c
imm c 2

# fd in a
imm a 0

sys read a

# d has the num to read
ldm d b

# reset stack
stk a 0

# memory[1016] = iteration count
imm a 1016
imm b 0
stm a b

# going to read in 1024 at a time
# save the sip on the stack

stk 0 i

# memory[1024] = buf
# b is the buf

imm b 1024

# len in c
imm c 1024

# fd in a
imm a 0

# amount read is in c
sys read c

# write it to fd 11 
imm a 11

sys write a

# increment the interation count by c (the amount read)
imm a 1016
ldm b a
add c b
stm a c

# check, if we've read the required number of bytes then quit, otherwise jump back!
stk a 0
stk 0 a
cmp d c
jmp != a

sys exit d


