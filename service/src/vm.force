// VM constants

# from OS
extern write_bytes(fd, bytes, num);
extern read_bytes(fd, num);
extern open_file(filename, flags);

# from shell
extern arg_to_arg(arg);
extern arg_to_stdout_fd(arg);

define_constant(TRACE, 0);

define_constant(O_WRONLY, 0x0001);
define_constant(O_CREAT, 0x010);
define_constant(O_TRUNC, 0x020);
define_constant(O_RDONLY, 0x0000);
define_constant(O_RDWR, 0x0002);


define_constant(WORD_SIZE, 8);
define_constant(INSTRUCTION_SIZE, 4);
define_constant(MEM_LENGTH, 4096);

define_constant(STACK_DIRECTION, -1 * WORD_SIZE);

define_constant(REGISTER_LENGTH, 7 * WORD_SIZE);
define_constant(REG_A, 0 * WORD_SIZE);
define_constant(REG_B, 1 * WORD_SIZE);
define_constant(REG_C, 2 * WORD_SIZE);
define_constant(REG_D, 3 * WORD_SIZE);
define_constant(REG_S, 4 * WORD_SIZE);
define_constant(REG_I, 5 * WORD_SIZE);
define_constant(REG_F, 6 * WORD_SIZE);

define_constant(INST_OP_MASK, 0xFF);
define_constant(INST_ARG1_MASK, 0xFF00);
define_constant(INST_ARG1_SHIFT, 8);
define_constant(INST_ARG2_MASK, 0xFFFF0000);
define_constant(INST_ARG2_SHIFT, 16);

define_constant(INST_IMM, 1);
define_constant(INST_STK, 2);
define_constant(INST_ADD, 4);
define_constant(INST_STM, 8);
define_constant(INST_LDM, 16);
define_constant(INST_JMP, 32);
define_constant(INST_CMP, 64);
define_constant(INST_SYS, 128);

define_constant(SPEC_REG_A, 1);
define_constant(SPEC_REG_B, 2);
define_constant(SPEC_REG_C, 4);
define_constant(SPEC_REG_D, 8);
define_constant(SPEC_REG_S, 16);
define_constant(SPEC_REG_I, 32);
define_constant(SPEC_REG_F, 64);

define_constant(SYS_OPEN, 1);
define_constant(SYS_READ, 2);
// Extra space
define_constant(SYS_WRITE, 8);
// Extra space
define_constant(SYS_EXIT, 32);

define_constant(FLAG_L, 1);
define_constant(FLAG_G, 2);
define_constant(FLAG_E, 4);
define_constant(FLAG_N, 8);
define_constant(FLAG_Z, 16);

defun min(a, b)
{
   to_return = a;
   if (b < a)
   {
      to_return = b;
   }
   return to_return;
}

defun write_register(registers, reg_spec, new_value)
{
   if (reg_spec == SPEC_REG_A)
   {
      registers[REG_A] = new_value;
   }
   else {
      if (reg_spec == SPEC_REG_B)
      {
         registers[REG_B] = new_value;
      }
      else {
         if (reg_spec == SPEC_REG_C)
         {
            registers[REG_C] = new_value;
         }
         else {
            if (reg_spec == SPEC_REG_D)
            {
               registers[REG_D] = new_value;
            }
            else { 
               if (reg_spec == SPEC_REG_S)
               {
                  registers[REG_S] = new_value;
               }
               else {
                  if (reg_spec == SPEC_REG_I)
                  {
                     registers[REG_I] = new_value;
                  }
                  else {
                     if (reg_spec == SPEC_REG_F)
                     {
                        registers[REG_F] = new_value;
                     }
                  }
               }
            }
         }
      }
   }
   // TODO: should we crash here?
   return new_value ^ new_value;
}

defun read_register(registers, reg_spec)
{
   to_return = -1;
   if (reg_spec == SPEC_REG_A)
   {
      to_return = registers[REG_A];
   }
   else {
      if (reg_spec == SPEC_REG_B)
      {
         to_return = registers[REG_B];
      }
      else {
         if (reg_spec == SPEC_REG_C)
         {
            to_return = registers[REG_C];
         }
         else {
            if (reg_spec == SPEC_REG_D)
            {
               to_return = registers[REG_D];
            }
            else {
               if (reg_spec == SPEC_REG_S)
               {
                  to_return = registers[REG_S];
               }
               else {
                  if (reg_spec == SPEC_REG_I)
                  {
                     to_return = registers[REG_I];
                  }
                  else {
                     if (reg_spec == SPEC_REG_F)
                     {
                        to_return = registers[REG_F];
                     }
                  }
               }
            }
         }
      }
   }
   // TODO: should we crash here?
   return to_return;
}

defun read_memory(memory, address)
{
   return memory[address];
}

defun write_memory(memory, address, value)
{
   memory[address] = value;
   if (memory == memory)
   {
      return memory[address];
   }
}

defun interpret_imm(memory, registers, instruction)
{
   if (TRACE)
   {
      OUTS_LITERAL("imm\n");
   }
   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   result = write_register(registers, arg1, arg2);
   return result ^ result;
}

defun interpret_add(memory, registers, instruction)
{
   if (TRACE)
   {
      OUTS_LITERAL("add\n");
   }
   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   arg1_value = read_register(registers, arg1);
   arg2_value = read_register(registers, arg2);

   new_value = arg1_value + arg2_value;
   if (TRACE)
   {
      OUTD(arg1_value);
      OUTD(arg2_value);
      OUTD(new_value);
   }

   result = write_register(registers, arg1, new_value);

   return result ^ result;
}

defun interpret_stk(memory, registers, instruction)
{
   if (TRACE)
   {
      OUTS_LITERAL("stk\n");
   }
   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   pop = 0;
   if (arg1)
   {
      // This is a pop
      if (TRACE)
      {
         OUTS_LITERAL("pop\n");
      }
      stack_addr = registers[REG_S];
      stack_value = read_memory(memory, stack_addr);
      result = write_register(registers, arg1, stack_value);
      registers[REG_S] = stack_addr - STACK_DIRECTION;
      pop = result ^ result;
   }

   push = 0;
   if (arg2)
   {
      // this is a push
      if (TRACE)
      {
         OUTS_LITERAL("push\n");
      }
      arg2_value = read_register(registers, arg2);
      stack_addr = registers[REG_S] + STACK_DIRECTION;

      result = write_memory(memory, stack_addr, arg2_value);
      registers[REG_S] = stack_addr;
      push = result ^ result;
   }

   return (pop ^ pop) + (push ^ push);
}

defun interpret_stm(memory, registers, instruction)
{
   // memory[reg[arg1]] = reg[arg2]
   if (TRACE)
   {
      OUTS_LITERAL("stm\n");
   }

   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   if (TRACE)
   {
      OUTD(arg1);
      OUTD(arg2);
   }

   arg1_value = read_register(registers, arg1);
   arg2_value = read_register(registers, arg2);

   if (TRACE)
   {
      OUTD(arg1_value);
      OUTD(arg2_value);
   }

   result = write_memory(memory, arg1_value, arg2_value);
   return result^result;
}

defun interpret_ldm(memory, registers, instruction)
{
   // reg[arg1] = memory[reg[arg2]]
   if (TRACE)
   {
      OUTS_LITERAL("ldm\n");
   }

   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   if (TRACE)
   {
      OUTD(arg1);
      OUTD(arg2);
   }

   arg2_value = read_register(registers, arg2);
   if (TRACE)
   {
      OUTD(arg2_value);
   }

   memory_value = read_memory(memory, arg2_value);
   if (TRACE)
   {
      OUTD(memory_value);
   }

   result = write_register(registers, arg1, memory_value);
   return result ^ result;
}

defun interpret_cmp(memory, registers, instruction)
{
   if (TRACE)
   {
      OUTS_LITERAL("cmp\n");
   }

   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   arg1_value = read_register(registers, arg1);
   arg2_value = read_register(registers, arg2);
   if (TRACE)
   {
      OUTD(arg1_value);
      OUTD(arg2_value);
   }

   flag = 0;
   if (arg1_value < arg2_value)
   {
      flag = flag | FLAG_L;
   }

   if (arg1_value > arg2_value)
   {
      flag = flag | FLAG_G;
   }

   if (arg1_value == arg2_value)
   {
      flag = flag | FLAG_E;
   }

   if (arg1_value != arg2_value)
   {
      flag = flag | FLAG_N;
   }

   if ((arg1_value == 0) & (arg2_value == 0))
   {
      flag = flag | FLAG_Z;
   }

   result = write_register(registers, SPEC_REG_F, flag);

   return result ^ result;
}

defun interpret_jmp(memory, registers, instruction)
{
   if (TRACE)
   {
      OUTS_LITERAL("jmp\n");
   }
   flags = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;

   // flags == 0 is an unconditional jump
   // otherwise flags (arg1) must be the same as the F register
   flag_register = registers[REG_F];
   jump = 0;
   if ((flags == 0) | (flags & flag_register))
   {
      dest = read_register(registers, arg2);
      if (TRACE)
      {
         OUTS_LITERAL("taken\n");
         OUTD(dest);
      }
      registers[REG_I] = dest;
      if (1)
      {
         jump = dest ^ dest;
      }
   }
   else
   {
      if (TRACE)
      {
         OUTS_LITERAL("!taken\n");
      }
      jump = -1;
   }

   return jump ^ jump;
}

defun interpret_sys(memory, registers, instruction)
{
   if (TRACE)
   {
      OUTS_LITERAL("sys\n");
   }

   arg1 = (instruction & INST_ARG1_MASK) >> INST_ARG1_SHIFT;
   arg2 = (instruction & INST_ARG2_MASK) >> INST_ARG2_SHIFT;
   if (TRACE)
   {
      OUTD(arg1);
   }
   open_output = 0;
   if (arg1 & SYS_OPEN)
   {
      if (TRACE)
      {
         OUTS_LITERAL("open\n");
      }
      // arg2 = open_file(&reg_a, reg_b)
      fname = memory[registers[REG_A]];
      flags = registers[REG_B];

      open_output = open_file(fname, flags);
      open_output = write_register(registers, arg2, open_output);
   }

   write_output = 0;
   if (arg1 & SYS_WRITE)
   {
      if (TRACE)
      {
         OUTS_LITERAL("write\n");
      }
      // arg2 = write_bytes(reg_a, &reg_b, min(reg_c, WORD_SIZE));
      data_addr = registers[REG_B];
      len = registers[REG_C];
      fd = registers[REG_A];

      if (TRACE)
      {
         OUTD(fd);
         OUTD(data_addr);
         OUTD(len);
      }
      write_output = 0;
      i = 0;
      while (i < len)
      {
         data = memory[data_addr];
         write_output = write_bytes(fd, data, 1);
         data_addr = data_addr + 1;
         i = i + 1;
         if (data_addr == MEM_LENGTH)
         {
            i = len;
         }
      }
      write_output = write_register(registers, arg2, write_output);
   }

   exit_output = 0;
   if (arg1 & SYS_EXIT)
   {
      if (TRACE)
      {
         OUTS_LITERAL("exit\n");
      }
      registers[REG_I] = MEM_LENGTH;
      write_register(registers, arg2, 0);
      exit_output = 0;
   }

   read_output = 0;
   if (arg1 & SYS_READ)
   {
      if (TRACE)
      {
         OUTS_LITERAL("read\n");
      }
      data_addr = registers[REG_B];
      len = registers[REG_C];
      fd = registers[REG_A];
      if (TRACE)
      {
         OUTD(fd);
         OUTD(data_addr);
         OUTD(len);
      }
      read_output = 0;
      i = 0;
      done = 0;
      while (done == 0)
      {
         original_data = memory[data_addr];
         ready_data = original_data >> 8;
         ready_data = ready_data << 8;
         new_byte = read_bytes(fd, 1);
         if (new_byte != -1)
         {
            new_data = ready_data | new_byte;
            memory[data_addr] = new_data;
            data_addr = data_addr + 1;
            i = i + 1;
         }
         else
         {
            done = 1;
         }
         if (data_addr == MEM_LENGTH)
         {
            done = 1;
         }
         if (i == len)
         {
            done = 1;
         }
      }
      read_output = write_register(registers, arg2, i);
   }
   

   return write_output ^ open_output ^ exit_output ^ read_output;
}


defun interpret_instruction(memory, registers, instruction)
{
   op = instruction & INST_OP_MASK;
   imm_output = 0;
   if (op & INST_IMM)
   {
      imm_output = interpret_imm(memory, registers, instruction);
   }

   add_output = 0;
   if (op & INST_ADD)
   {
      add_output = interpret_add(memory, registers, instruction);
   }

   stk_output = 0;
   if (op & INST_STK)
   {
      stk_output = interpret_stk(memory, registers, instruction);
   }

   stm_output = 0;
   if (op & INST_STM)
   {
      stm_output = interpret_stm(memory, registers, instruction);
   }

   ldm_output = 0;
   if (op & INST_LDM)
   {
      ldm_output = interpret_ldm(memory, registers, instruction);
   }

   cmp_output = 0;
   if (op & INST_CMP)
   {
      cmp_output = interpret_cmp(memory, registers, instruction);
   }

   jmp_output = 0;
   if (op & INST_JMP)
   {
      jmp_output = interpret_jmp(memory, registers, instruction);
   }

   sys_output = 0;
   if (op & INST_SYS)
   {
      sys_output = interpret_sys(memory, registers, instruction);
   }

   return add_output ^ stk_output ^ stm_output ^ ldm_output ^ cmp_output ^ jmp_output ^ sys_output;
}

defun interpreter_loop(memory, registers)
{
   i = 0;
   while(registers[REG_I] != MEM_LENGTH)
   {
      if (TRACE)
      {
         OUTS_LITERAL("Inst\n");
      }
      ip = registers[REG_I];
      if (TRACE)
      {
         OUTD(ip);
      }
      registers[REG_I] = ip + INSTRUCTION_SIZE;
      instruction = memory[ip % MEM_LENGTH];
      if (TRACE)
      {
         OUTD(instruction & 0xFFFFFFFF);
         OUTD(registers[REG_S]);
      }
      result = interpret_instruction(memory, registers, instruction);
      registers = registers + (result ^ result);
      i = i + 1 + (result ^ result);
      if (TRACE)
      {
         OUTS("\n"+(i^i));
      }
   }
   return i ^ i;
}

defun load_code(filename, code)
{
   fd = open_file(filename, O_RDONLY);
   if (fd == -1)
   {
      OUTS_LITERAL("filename does not exist");
      return code;
   }
   else
   {
      i = 0;
      byte = read_bytes(fd, 1);
      while (byte != -1)
      {
         // OUTD(byte);
         code[i] = byte;

         i = i + 1;
         if (i == MEM_LENGTH)
         {
            byte = -1;
         }
         else
         {
            byte = read_bytes(fd, 1);
         }
         code = code;
      }
      return code + (i ^ i) + (byte ^ byte);
   }
}

defun main(arg)
{
   filename = arg_to_arg(arg);
   memory = NEW_ARRAY(MEM_LENGTH);
   registers = NEW_ARRAY(REGISTER_LENGTH);
   registers[REG_I] = 0;
   registers[REG_S] = MEM_LENGTH;

   memory = load_code(filename, memory);

   if (TRACE)
   {
      OUTS_LITERAL("In the VM\n");
   }

   result = interpreter_loop(memory, registers);
   return result;
}
export main;

   
